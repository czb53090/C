# include <stdio.h>
# include <stdlib.h>

int main(void)
{
	int fac(int n);
	int n, y;

	printf("input an integer number:");
	scanf("%d", &n);

	y = fac(n);
	printf("%d! = %d\n", n, y);

	system("pause");
	return 0;
}

int fac(int n)
{
	int f;

	if(n < 0)
		printf("n<0, data error!");
	else if (n==0 || n==1)
		f = 1;
	else
		f = n * fac(n-1);
	return f;
}

/*在Vc++6.0中的输出结果是：
--------------------------
input an integer number:10
10! = 3628800
--------------------------
    总结：
		n = 10, ┌→f(10) ←  f = 10 * f(9) ─┐
				│  f(9)  ←  f = 9  * f(8)	  ││函
				│递f(8)  ←  f = 8  * f(7)	  ││数
				│归f(7)  ←  f = 7  * f(6)	  ││嵌
				│	f(6)  ←  f = 6  * f(5)	  ││套
				│	f(5)  ←  f = 5  * f(4)	  ││循
				│	f(4)  ←  f = 4  * f(3)   ││环
				│	f(3)  ←  f = 3  * f(2)	  │↓
				│  f(2)  ←  f = 2  * f(1)	  │
				└─f(1)  ←  f = 1		    ←┘
		
		主要问题是刚开始指向函数不知道f(9)的值，f(9)函数中又不知道f(8)
		的值，直到函数嵌套到f(1)中直到f=1，即f(1)=1,实现递归，将所有
		未知函数的值补上，从而算出n的阶乘。
		f(10) = 10*(9*(8*(7*(6*(5*(4*(3*(2*1))))))))
				┗┯┿-┿┿━┿┿━┿┿━┿┛
				 f(9)  ┊┊  ┊┊  ┊┊  ┊
				    ┗┯-┿━┿┿━┿┿━┿┛
				     f(8)┊  ┊┊  ┊┊  ┊
					   ┗┯━┿┿━┿┿━┿┛
					    f(7)   ┊  ┊┊  ┊
					     ┗┯━┿━┿┿━┿┛
					       f(6)┊  ┊┊  ┊
							 ┗┯━┿┿━┿┛
							  f(5)   ┊  ┊
								┗┯-┿━┿┛
								 f(4)┊  ┊
								   ┗┯━┿┛
									f(3) ┊
									 ┗┯┿┛
									   f(2)
									     ┗┛
										 f(1)

		递归终止条件为 n == 0 或 n == 1
		当n == 1, , f =1, f(1) = 1  ------  得到f(1)为确切的值
				
*/